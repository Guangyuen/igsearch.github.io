<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>跨域的实现</title>
      <link href="/2020/02/20/%E8%B7%A8%E5%9F%9F-1/"/>
      <url>/2020/02/20/%E8%B7%A8%E5%9F%9F-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Node基础学习笔记01 —— 【了解Node】</p></blockquote><p>​    </p><h2 id="跨域的实现原理"><a href="#跨域的实现原理" class="headerlink" title="跨域的实现原理"></a>跨域的实现原理</h2><blockquote><p style="text-indent:2em">XMLHttpRequest对象默认情况下无法获取非同源服务器下的数据，所以可以利用script标签的src属性引入一个外部文件，这个外部文件是不涉及同源策略的影响的。</p></blockquote><blockquote><p style="text-indent:2em">跨域的本质其实就是服务器返回一个方法的调用，这个方法是我们是事先定义好的，而方法中的参数就是我们想要的数据。</p></blockquote><blockquote><ol><li>访问外部js文件</li><li>动态创建script标签传入动态参数</li><li>前端界面决定方法名称</li><li>给window对象增加属性进行方法定义</li></ol></blockquote><h2 id="淘宝关键词案例"><a href="#淘宝关键词案例" class="headerlink" title="淘宝关键词案例"></a>淘宝关键词案例</h2><blockquote><p>淘宝提示词接口如下：</p><ol><li>地址：<a href="https://suggest.taobao.com/sug" target="_blank" rel="noopener">https://suggest.taobao.com/sug</a></li><li>请求类型：get</li><li>参数：q——关键词，callback——回调方法名称</li><li>返回数据格式：json</li></ol></blockquote><pre><code>window.onload = function(){            var btn = document.querySelector(&quot;#btn&quot;);            btn.onclick = function(){                var keywordValue = document.querySelector(&quot;#keyword&quot;).value;                var script = document.createElement(&quot;script&quot;);                script.src = &quot;https://suggest.taobao.com/sug?q=&quot;+keywordValue+&quot;&amp;callback=test&quot;;                window[&quot;test&quot;] = function(data){                    var tdTag = &quot;&quot;;                    for(var i=0;i&lt;data.result.length;i++){                        var temp = data.result[i];                        var tempSug = temp[0];                        tdTag += &quot;&lt;tr&gt;&lt;td&gt;&quot;+tempSug+&quot;&lt;/td&gt;&lt;tr&gt;&quot;;                    }                    var tbody = document.querySelector(&quot;tbody&quot;);                    tbody.innerHTML = tdTag;                }                var head = document.querySelector(&quot;head&quot;);                head.appendChild(script);            }        }</code></pre><blockquote><p>结果如下</p></blockquote><p> <img src="https://cdn.jsdelivr.net/gh/jinxb/jinxb.github.io/post_image/%E8%B7%A8%E5%9F%9F.png" alt="跨域"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 跨域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax的封装</title>
      <link href="/2020/02/19/ajax-1/"/>
      <url>/2020/02/19/ajax-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原生js封装一个ajax</p></blockquote><h2 id="将ajax封装"><a href="#将ajax封装" class="headerlink" title="将ajax封装"></a>将ajax封装</h2><pre><code>function myAjax(type,url,params,dataType,callback,async){        var xhr = null;        //1.创建异步对象        if(window.XMLHttpRequest){            xhr = new XMLHttpRequest();        }else{            xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//兼容IE6以下的浏览器        }        if(type == &quot;get&quot;){            //判断参数存在且不为空            if(params &amp;&amp; params != &quot;&quot;){                url += &quot;?&quot; + params;            }        }        //2.设置请求行open(请求方式,请求url,异步)        xhr.open(type,url,async);        if(type == &quot;get&quot;){            xhr.send(null);        }else if(type == &quot;post&quot;){        //3.post方式 设置请求头，请求体            xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);            xhr.send(params);        }        //4.让异步对象接收服务器的响应数据        if(async){            xhr.onreadystatechange = function(){                if(xhr.readyState == 4 &amp;&amp; xhr.status ==200){                    var result = null;                    //判断服务器响应的数据类型                    if(dataType == &quot;json&quot;){                        result = JSON.parse(xhr.responseText);                    }else if(dataType == &quot;xml&quot;){                        result = xhr.responseXML;                    }else{                        result = xhr.responseText;                    }                    //回调函数                    if(callback){                        callback(result);                    }                }            }        }   }</code></pre><blockquote><p>以上封装方式有两个缺点：<br>1.参数的顺序不可变<br>2.参数没有默认值，每次调用都需要传递</p></blockquote><h2 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h2><blockquote><p>由于以上封装方法存在缺点，进一步优化，将封装的方式变为一个对象；</p></blockquote><pre><code>function myAjax(obj) {        var defaults = {            type: &quot;get&quot;,            url: &quot;#&quot;,            dataType: &quot;json&quot;,            data: {},            async: true,            success: function (result) {                console.log(result);            }        }        //obj中的属性，覆盖到defults中的属性        //1.如果某些属性只存在于obj中，则会给defaults增加属性        //2.如果某些属性obj和defaults中都存在，会将defaults中的默认值覆盖        //3.如果某些属性只在defaults中存在，在obj中不存在，这时候将保留defaults中预定义的内容        for (var key in obj) {            defaults[key] = obj[key];        }        //第一步        var xhr = null;        if (window.XMLHttpRequest) {            xhr = new XMLHttpRequest();        } else {            xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);        }        //得到params        var params = &quot;&quot;;        for (var attr in defaults.data) {            params += attr + &quot;=&quot; + defaults.data[attr] + &quot;&amp;&quot;;        }        if (params) {            params = params.substring(0, params.length - 1);        }        if (defaults.type == &quot;get&quot;) {            defaults.url += &quot;?&quot; + params;        }        //第二步        xhr.open(defaults.type, defaults.url, defaults.async);        if (defaults.type == &quot;get&quot;) {            xhr.send(null);        } else if (defaults.type == &quot;post&quot;) {            xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);            xhr.send(params);        }        //第三步        if (defaults.async) {            xhr.onreadystatechange = function () {                if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {                    var result = null;                    if (defaults.dataType == &quot;json&quot;) {                        result = JSON.parse(xhr.responseText);                    } else if (defaults.dataType == &quot;xml&quot;) {                        result = xhr.responseXML;                    } else {                        result = xhr.responseText;                    }                    defaults.success(result);                }            }        } else {            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {                var result = null;                if (defaults.dataType == &quot;json&quot;) {                    result = JSON.parse(xhr.responseText);                } else if (defaults.dataType == &quot;xml&quot;) {                    result = xhr.responseXML;                } else {                    result = xhr.responseText;                }                defaults.success(result);            }        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习之生命周期函数</title>
      <link href="/2020/02/08/vue-1/"/>
      <url>/2020/02/08/vue-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vue生命周期函数</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/jinxb/jinxb.github.io/images/lifecycle.png" alt="此处输入图片的描述"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue </tag>
            
            <tag> js进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器访问服务器的过程</title>
      <link href="/2020/02/08/%E9%9D%A2%E8%AF%95-02/"/>
      <url>/2020/02/08/%E9%9D%A2%E8%AF%95-02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从浏览器地址栏输入URL到展示页面经历了什么~</p></blockquote><ol><li>在浏览器地址栏中输入网址。</li><li>浏览器通过用户在地址栏中输入的url构建HTTP请求报文。</li><li>浏览器发起DNS解析请求，将域名转换为IP地址</li><li>浏览器将请求报文发送给服务器。</li><li>服务器接收请求报文，并解析。</li><li>浏览器处理用户请求，并将处理结果封装成HTTP响应报文。</li><li>服务器将HTTP响应报文发送给浏览器。</li><li>浏览器接收服务器响应的HTTP报文，并解析。</li><li>浏览器解析HTML页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。</li><li>最终浏览器展示出页面。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记&lt;二&gt;</title>
      <link href="/2020/01/12/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/"/>
      <url>/2020/01/12/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02/</url>
      
        <content type="html"><![CDATA[<blockquote><center><h2>Node基础学习笔记02 —— 【fs模块】</h2></center></blockquote><a id="more"></a> <h3 id="2-1-fs模块"><a href="#2-1-fs模块" class="headerlink" title="- 2.1 fs模块"></a><font color="#FF0000">- 2.1 fs模块</font></h3><blockquote><p>fs文件系统模块，这是一个非常重要的模块，对文件的操作都基于它,该模块的所有方法都有同步和异步两种方式。对于异步的回调方法，第一次参数都是error对象，error first</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fs=require('fs')</span><br></pre></td></tr></table></figure><h3 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="- 2.2 属性"></a><font color="#FF0000">- 2.2 属性</font></h3><h4 id="文件-夹-是否存在"><a href="#文件-夹-是否存在" class="headerlink" title="文件(夹)是否存在"></a>文件(夹)是否存在</h4><blockquote><p>fs.access(filepath,exist=&gt;{})</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.access(filepath,error=&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h4><blockquote><p>fs.stat(path,(error,stats)=&gt;{})</p></blockquote><ul><li><p>stats.isFile() : 是否是文件</p></li><li></li><li><p>stats.isDirectory(): 是否是文件夹</p></li><li><p>stats.mod: 获取权限</p></li><li><p>stats.size: 字节长度</p></li><li><p>stats.ctime:State Change Time,属性或内容上次被修改的时间 (设置缓存的响应头可能会用到)</p></li><li><p>stats.mtime:Modified time,档案的内容上次被修改的时间 (设置缓存的响应头可能会用到)</p></li><li><p>stats.atime:Access time,上次被读取的时间</p></li></ul><h3 id="2-3-文件"><a href="#2-3-文件" class="headerlink" title="- 2.3 文件"></a><font color="#FF0000">- 2.3 文件</font></h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><blockquote><p>fs没有直接创建文件的方法。正常逻辑下，写入文件前需要确认文件是否存在，如果不存在需要创建后才能写入，而fs模块不需要这么做，在有写入功能的几个api中，如果目标文件不存在，node为自动创建该文件然后写入。常用的几个写入功能的api有：</p></blockquote><ul><li>fs.appendFile()</li><li>fs.writeFile()</li><li>fs.createWriteStream()</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><blockquote><p>fs.unlink()</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.unlink(filepath,error=&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><blockquote><p>fs.copyFile(src, dest[, flags], callback)</p></blockquote><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><blockquote><p>fs.rename(oldPath, newPath, callback)</p></blockquote><p>可实现文件的重命名和移动</p><h4 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h4><h5 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h5><blockquote><p>fs.open(filename,flags,[mode],callback);</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.open(<span class="string">'./1,txt'</span>,<span class="string">'r'</span>,<span class="number">0600</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>1、<strong>写文件</strong>：<code>fs.writeFile(file, data[, options], callback);</code></p><ul><li><p>参数1：要写入的文件路径，<strong>必填</strong>。</p></li><li><p>参数2：要写入的数据，<strong>必填</strong>。</p></li><li><p>参数3：写入文件时的选项，比如：文件编码，选填。</p></li><li><p>参数4：文件写入完毕后的回调函数，<strong>必填</strong>。</p></li><li><p>写文件注意：</p><ul><li><p>该操作采用异步执行</p></li><li><p>如果文件已经存在则替换掉</p></li><li><p>默认写入的文件编码为utf8</p></li><li><p>回调函数有1个参数：err，表示在写入文件的操作过程中是否出错了。</p></li><li><p>如果出错了<code>err != null</code>，否则 <code>err === null</code></p></li></ul></li></ul><p>2、<strong>读文件</strong>：<code>fs.readFile(file[, options], callback)</code></p><ul><li><p>参数1：要读取的文件路径，<strong>必填</strong>。</p></li><li><p>参数2：读取文件时的选项，比如：文件编码。选填。</p></li><li><p>参数3：文件读取完毕后的回调函数，<strong>必填</strong>。</p></li><li><p>读文件注意：</p><ul><li>该操作采用异步执行</li><li>回调函数有两个参数，分别是err和data</li><li>如果读取文件时没有指定编码，那么返回的将是原生的二进制数据；如果指定了编码，那么会根据指- 定的编码返回对应的字符串数据。</li></ul></li></ul><blockquote><p>注意：</p><p>文件操作中的<code>./</code>表示当前路径，相对的是执行node命令的路径，而不是当前被执行的<code>*.js</code>文件的实际路径。</p><p><code>__dirname</code>才永远表示当前被执行的<code>*.js</code>文件的实际路径</p><p><code>/</code>表示根目录, 读取文件或写入文件的时候写<code>/</code>目录，在Windows下相当于当前磁盘根目录（比如：c:\ 或 d:\ 或 e:\  等，在Mac下相当于硬盘根目录 <code>/</code>）</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------------------------- 写文件 -----------------------------</span></span><br><span class="line"><span class="comment">// 加载文件操作模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建要写入的文件的字符串</span></span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">'你好，世界！你好 Node.js.'</span>;</span><br><span class="line"><span class="comment">// 执行文件写入操作</span></span><br><span class="line">fs.writeFile(<span class="string">'./data.txt'</span>, msg, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'---'</span> + err + <span class="string">'----'</span>);</span><br><span class="line">  <span class="comment">// /判断是否写入文件出错了</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件写入出错了，详细错误信息：'</span> + err);</span><br><span class="line">    <span class="comment">// 把错误继续向上抛出</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件写入成功！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------------------------- 读文件 -----------------------------</span></span><br><span class="line"><span class="comment">// 加载文件操作模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行文件读取操作</span></span><br><span class="line">fs.readFile(<span class="string">'./data.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出err  和 data</span></span><br><span class="line">  <span class="comment">// console.log('error: ' + err);</span></span><br><span class="line">  <span class="comment">// console.log('data: ' + data);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取出错啦！详细信息: '</span> + err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件读取成功，以下是文件内容：'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><blockquote><p>fs.appendFile(path, data[, options], callback)</p></blockquote><ul><li>path : 目标路径</li><li>data ：写入内容，string或者buffer<ul><li>options：</li><li>flags：默认为’a’ ;</li><li>encoding: 默认编码为utf8</li><li>mode: 权限编码，默认读写，无执行</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveLog</span>(<span class="params">logpath, content</span>) </span>&#123;</span><br><span class="line">      debug(logpath)</span><br><span class="line">      content = <span class="string">`\n <span class="subst">$&#123;(<span class="keyword">new</span> <span class="built_in">Date</span>()).toString()&#125;</span> \n <span class="subst">$&#123;content&#125;</span> \n`</span></span><br><span class="line">      fs.appendFile(logpath, content, &#123;</span><br><span class="line">        flags: <span class="string">'a+'</span>,</span><br><span class="line">        encoding: <span class="string">'utf8'</span>,</span><br><span class="line">        mode: <span class="number">0o666</span></span><br><span class="line">      &#125;, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">let</span> errStr = util.inspect(err)</span><br><span class="line">          debug(chalk.red(<span class="string">`save log error: \n <span class="subst">$&#123;errStr&#125;</span>`</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><blockquote><p>fs.mkdir(path[, options], callback)</p></blockquote><ul><li>npm包： mkdirp，递归创建目录及其子目录</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载文件操作模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个目录</span></span><br><span class="line">fs.mkdir(<span class="string">'./test-mkdir'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建目录出错了，详细信息如下：'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'目录创建成功！'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载文件操作模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建 '01-资料' 目录</span></span><br><span class="line">fs.mkdir(<span class="string">'./01-资料'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.1 创建 '01-笔记' 目录</span></span><br><span class="line">  fs.mkdir(<span class="string">'./01-资料/01-笔记'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.2 创建 '02-任务' 目录</span></span><br><span class="line">  fs.mkdir(<span class="string">'./01-资料/02-任务'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.3 创建 '03-素材' 目录</span></span><br><span class="line">  fs.mkdir(<span class="string">'./01-资料/03-素材'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.4 创建 '04-笔记' 目录</span></span><br><span class="line">  fs.mkdir(<span class="string">'./01-资料/04-笔记'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建 '02-源代码' 目录</span></span><br><span class="line">fs.mkdir(<span class="string">'./02-源代码'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 创建 '预习代码'目录</span></span><br><span class="line">  fs.mkdir(<span class="string">'./02-源代码/预习代码'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建 '03-视频' 目录</span></span><br><span class="line">fs.mkdir(<span class="string">'./03-视频'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建 '04-其他资料' 目录</span></span><br><span class="line">fs.mkdir(<span class="string">'./04-其他资料'</span>);</span><br></pre></td></tr></table></figure><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><ol><li>异步操作无法通过 try-catch 来捕获异常，要通过判断 error 来判断是否出错。</li><li>同步操作可以通过 try-catch 来捕获异常。</li><li>不要使用 <code>fs.exists(path, callback)</code> 来判断文件是否存在，直接判断 error 即可</li><li>文件操作时的路径问题<ul><li>在读写文件的时候 ‘./‘ 表示的是当前执行node命令的那个路径，不是被执行的js文件的路径</li><li>__dirname, 表示的永远是”当前被执行的js的目录”</li><li>__filename, 表示的是”被执行的js的文件名（含路径)”</li></ul></li><li>error-first 介绍(错误优先)</li></ol><h5 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h5><blockquote><p>fs.rmdir(path, callback)</p></blockquote><ul><li>只能用来删除空目录！！！ 如有子目录或包含文件，则需要先删除子目录和文件，否则报错</li></ul><h5 id="递归删除"><a href="#递归删除" class="headerlink" title="递归删除"></a>递归删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">'dirr'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delDirrSync</span>(<span class="params">dirPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stats = fs.statSync(dirPath)</span><br><span class="line">  <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">    fs.unlinkSync(dirPath)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stats.isDirectory()) &#123;</span><br><span class="line">    <span class="keyword">let</span> files = fs.readdirSync(dirPath)</span><br><span class="line">    <span class="keyword">if</span> (files.length === <span class="number">0</span>) &#123;</span><br><span class="line">      fs.rmdirSync(dirPath)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      files.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filepath = path.join(dirPath, item)</span><br><span class="line">        delDirrSync(filepath)</span><br><span class="line">      &#125;)</span><br><span class="line">      delDirrSync(dirPath)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">delDirrSync(rootDir)</span><br></pre></td></tr></table></figure><h5 id="异步删除"><a href="#异步删除" class="headerlink" title="异步删除"></a>异步删除</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">'dirr'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delDirAsync</span>(<span class="params">dirPath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.access(dirPath, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        fs.stat(dirPath, (err, stats) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (stats.isFile()) &#123;</span><br><span class="line">            fs.unlink(dirPath, err =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(dirPath)</span><br><span class="line">                resolve(dirPath)</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> reject(err)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fs.readdir(dirPath, (err, files) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">Promise</span>.all(</span><br><span class="line">                  files.map(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> filePath = path.join(dirPath, file)</span><br><span class="line">                    <span class="keyword">return</span> delDirAsync(filePath)</span><br><span class="line">                  &#125;)</span><br><span class="line">                ).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                  <span class="built_in">console</span>.log(dirPath)</span><br><span class="line">                  fs.rmdir(dirPath, resolve)</span><br><span class="line">                &#125;</span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">delDirAsync(rootDir)</span><br></pre></td></tr></table></figure><h3 id="2-4-path模块"><a href="#2-4-path模块" class="headerlink" title="- 2.4 path模块"></a><font color="#FF0000">- 2.4 path模块</font></h3><blockquote><p>path.join(),path.resolve()的区别</p></blockquote><p>示例E:\web\test\abc.js里面写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path.join(__dirname,<span class="string">'/static/js'</span>) <span class="comment">//输出 E:\web\test\static\js</span></span><br><span class="line"></span><br><span class="line">path.join(__dirname,<span class="string">'./static/js'</span>) <span class="comment">//输出 E:\web\test\static\js</span></span><br><span class="line"></span><br><span class="line">path.join(<span class="string">'/file'</span>,<span class="string">'static'</span>) <span class="comment">//输出 file\static</span></span><br><span class="line"></span><br><span class="line">path.resolve()中的/会被解析为根目录</span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'/test'</span>,<span class="string">'/static/js'</span>) <span class="comment">//输出 E:\static\js</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'/test'</span>,<span class="string">'./static/js'</span>) <span class="comment">//输出 E:\test\static\js</span></span><br></pre></td></tr></table></figure><p>path.extname(path): 获取文件拓展名<br>path.basename(path[, ext])：获取文件名不含路径</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Node学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Node学习笔记 </tag>
            
            <tag> Node基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记&lt;一&gt;</title>
      <link href="/2020/01/08/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/"/>
      <url>/2020/01/08/node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01/</url>
      
        <content type="html"><![CDATA[<blockquote><center><h2>Node基础学习笔记01 —— 【了解Node】</h2></center></blockquote><a id="more"></a> <h3 id="1-1-node-js-是什么？"><a href="#1-1-node-js-是什么？" class="headerlink" title="- 1.1 node.js 是什么？"></a><font color="#FF0000">- 1.1 node.js 是什么？</font></h3><ol><li>node.js 是一个开发平台，有对应的编程语言、有语言运行时、有能实现特定功能的API（SDK：Software Development Kit）</li><li>该平台使用的编程语言是 JavaScript 语言。 </li><li>node.js 平台是基于 Chrome V8 JavaScript 引擎构建。</li><li>基于 node.js 可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）（借助 node-webkit、electron 等框架实现）、Web 应用程序（网站）</li></ol><p>PHP开发技术栈: LAMP - Linux Apache MySQL PHP</p><p>node.js 全栈开发技术栈: MEAN - MongoDB Express Angular Node.js</p><h3 id="1-2-node-js-有哪些特点？"><a href="#1-2-node-js-有哪些特点？" class="headerlink" title="- 1.2 node.js 有哪些特点？"></a><font color="#FF0000">- 1.2 node.js 有哪些特点？</font></h3><ol><li>事件驱动(当事件被触发时，执行传递过去的回调函数)</li><li>非阻塞 I/O 模型（当执行I/O操作时，不会阻塞线程）</li><li>单线程</li><li>拥有世界最大的开源库生态系统 —— npm。</li></ol><h3 id="1-3-Node-js-开发-Web-应用程序-和-PHP、Java、ASP-Net等传统模式开发Web应用程序区别"><a href="#1-3-Node-js-开发-Web-应用程序-和-PHP、Java、ASP-Net等传统模式开发Web应用程序区别" class="headerlink" title="- 1.3 Node.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别"></a><font color="#FF0000">- 1.3 Node.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别</font></h3><ol><li><strong>传统模式</strong><ul><li>有 Web 容器</li></ul></li></ol><p><img src="C:/Users/jinbin/Desktop/webpack%E5%AD%A6%E4%B9%A0/nodejs/01-Node.js%E4%BB%8B%E7%BB%8D/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/01-%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BA%B2/imgs/Web.png" alt="有Web容器开发模型"></p><ol start="2"><li><strong>Node.js开发Web应用程序</strong><ul><li>没有 Web 容器</li></ul></li></ol><p><img src="C:/Users/jinbin/Desktop/webpack%E5%AD%A6%E4%B9%A0/nodejs/01-Node.js%E4%BB%8B%E7%BB%8D/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/01-%E7%AC%94%E8%AE%B0%E5%A4%A7%E7%BA%B2/imgs/nodeWeb.png" alt="Node.js无Web容器开发模型"> </p><h3 id="1-4-node-js-网站"><a href="#1-4-node-js-网站" class="headerlink" title="- 1.4 node.js 网站"></a><font color="#FF0000">- 1.4 node.js 网站</font></h3><ol><li><a href="https://nodejs.org/" target="_blank" rel="noopener">node.js官方网站</a></li><li><a href="http://nodejs.cn/" target="_blank" rel="noopener">node.js中文网</a></li><li><a href="https://cnodejs.org/" target="_blank" rel="noopener">node.js 中文社区</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Node学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Node学习笔记 </tag>
            
            <tag> Node基础学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建对象几种形式</title>
      <link href="/2019/06/20/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F/"/>
      <url>/2019/06/20/js%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>创建对象几种形式</p></blockquote><a id="more"></a> <h2 id="方式一-Object构造函数模式"><a href="#方式一-Object构造函数模式" class="headerlink" title="方式一: Object构造函数模式"></a>方式一: Object构造函数模式</h2><ul><li>套路: 先创建空Object对象, 再动态添加属性/方法</li><li>适用场景: 起始时不确定对象内部数据</li><li>问题: 语句太多</li></ul><blockquote><pre><code>var p = new Object()//先创建空Object对象p = {} //此时内部数据是不确定的, 再动态添加属性/方法p.name = &apos;Tom&apos;p.age = 12p.setName = function (name) {  this.name = name}</code></pre></blockquote><h2 id="方式二-对象字面量模式"><a href="#方式二-对象字面量模式" class="headerlink" title="方式二: 对象字面量模式"></a>方式二: 对象字面量模式</h2><ul><li>套路: 使用{}创建对象, 同时指定属性/方法</li><li>适用场景: 起始时对象内部数据是确定的</li><li>问题: 如果创建多个对象, 有重复代码</li></ul><blockquote><pre><code>  var p = {  name: &apos;Tom&apos;,  age: 12,  setName: function (name) {    this.name = name  }}</code></pre></blockquote><h2 id="方式三-工厂模式"><a href="#方式三-工厂模式" class="headerlink" title="方式三: 工厂模式"></a>方式三: 工厂模式</h2><ul><li>套路: 通过工厂函数动态创建对象并返回</li><li>适用场景: 需要创建多个对象</li><li>问题: 对象没有一个具体的类型, 都是Object类型</li></ul><blockquote><pre><code>function createPerson(name, age) {   var obj = {//返回一个对象的函数    name: name,    age: age,    setName: function (name) {      this.name = name    }  }  return obj}</code></pre></blockquote><p>工厂模式无法识别对象的类型，因为它们直接由 Object() 构造函数创建，原型链上只有 Object.prototype 对象，不像Date、Array等。</p><h2 id="方式四-自定义构造函数模式"><a href="#方式四-自定义构造函数模式" class="headerlink" title="方式四: 自定义构造函数模式"></a>方式四: 自定义构造函数模式</h2><ul><li>套路: 自定义构造函数, 通过new创建对象</li><li>适用场景: 需要创建多个类型确定的对象</li><li>问题: 每个对象都有相同的数据, 浪费内存</li></ul><p>构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。</p><h1 id="1-构造函数的执行流程："><a href="#1-构造函数的执行流程：" class="headerlink" title="1.构造函数的执行流程："></a>1.构造函数的执行流程：</h1><p>1.立刻创建一个新的对象</p><p>2.将新建的对象设置为函数中this</p><p>3.逐行执行函数中的代码</p><p>4.将新建的对象作为返回值返回</p><blockquote><pre><code>function Person(name, age) {   this.name = name   this.age = age   this.setName = function (name) {     this.name = name   } }var p1 = new Person(&apos;Tom&apos;, 12)function Student(name, price) {     this.name = name     this.price = price     this.setName = function (name) {       this.name = name     }   } var s1 = new Student(&apos;Bob&apos;, 13000) console.log(p1 instanceof Person)//true console.log(s1 instanceof Student)//true console.log(p1,s1)</code></pre></blockquote><p>使用instanceof可以检查一个对象是否是一个类的实例。所有的对象都是Object的后代，所以任何对象和Object左instanceof检查时都会返回true。</p><h1 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2.注意点"></a>2.注意点</h1><p>p1和p2都是Person这个类的实例，所以都拥有setName这个方法，但是不同实例之间的方法是不一样的。在类中给实例增加的属性(this.xxx=xxx)属于当前实例的私有的属性，实例和实例之间是单独的个体，所以私有的属性之间是不相等的。</p><blockquote><p>var p2 = new Person(‘jack’, 12)<br>    console.log(p1.setName === p2.setName);</p></blockquote><p>每创建一个Person构造函数，在Person构造函数中，为每一个对象都添加了一个setName方法，也就是说构造函数每执行一次就会创建一个新的setName方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一模一样的，这是完全没有必要，完全可以使所有的对象共享同一个方法。</p><blockquote><pre><code>function Person(name, age) {   this.name = name   this.age = age   this.setName = fun }function fun(){   alert(&quot;Hello大家好，我是:&quot;+this.name);};</code></pre></blockquote><p>将函数定义在全局作用域这种方法，虽然会提升性能，但污染了全局作用域的命名空间,而且定义在全局作用域中也很不安全。那么有没有更好的办法呢？</p><p>方式五: 构造函数+原型的组合模式<br>套路: 自定义构造函数, 属性在函数中初始化, 方法添加到原型上<br>适用场景: 需要创建多个类型确定的对象<br>我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象就是我们所谓的原型对象。如果函数作为普通函数调用prototype没有任何作用。当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过<strong>proto</strong>来访问该属性。</p><blockquote><pre><code>function MyClass() {}var mc = new MyClass()console.log(mc.__proto__ === MyClass.prototype)//true</code></pre></blockquote><p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</p><blockquote><pre><code>function Person(name, age) { //在构造函数中只初始化一般函数  this.name = name  this.age = age}Person.prototype.setName = function (name) {  this.name = name}var p1 = new Person(&apos;Tom&apos;, 23)var p2 = new Person(&apos;Jack&apos;, 24)console.log(p1, p2) p1.setName(&quot;james&quot;)//p1没有这个方法，就会去原型对象中寻找 console.log(p1)//Person{name: &quot;james&quot;, age: 23}</code></pre></blockquote><p>以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习之旅 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript前端面试常考知识点(1)</title>
      <link href="/2019/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
      <url>/2019/06/20/js%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Javascript前端面试常考知识点(1)</p></blockquote><a id="more"></a> <h2 id="一、变量类型"><a href="#一、变量类型" class="headerlink" title="一、变量类型"></a>一、变量类型</h2><h1 id="1-JS-的数据类型分类"><a href="#1-JS-的数据类型分类" class="headerlink" title="1.JS 的数据类型分类"></a>1.JS 的数据类型分类</h1><p>根据 JavaScript 中的变量类型传递方式，分为基本数据类型和引用数据类型。其中基本数据类型包括Undefined、Null、Boolean、Number、String、Symbol (ES6新增，表示独一无二的值)，而引用数据类型统称为Object对象，主要包括对象、数组和函数。在参数传递方式上，基本类型是按值传递，引用类型是按共享传递。</p><p>题目：基本类型和引用类型的区别</p><p>基本类型和引用类型存储于内存的位置不同，基本类型直接存储在栈中,而引用类型的对象存储在堆中，与此同时，在栈中存储了指针，而这个指针指向正是堆中实体的起始位置。下面通过一个小题目，来看下两者的主要区别：</p><p>// 基本类型</p><blockquote><pre><code>var a = 10var b = ab = 20console.log(a)  // 10console.log(b)  // 20</code></pre></blockquote><p>上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：</p><p>// 引用类型</p><blockquote><pre><code>var a = {x: 10, y: 20}var b = ab.x = 100b.y = 200console.log(a)  // {x: 100, y: 200}console.log(b)  // {x: 100, y: 200}</code></pre></blockquote><p>上述代码中，a b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动</p><h1 id="2-数据类型的判断"><a href="#2-数据类型的判断" class="headerlink" title="2.数据类型的判断"></a>2.数据类型的判断</h1><p>1）typeof<br>typeof返回一个表示数据类型的字符串，返回结果包括：number、boolean、string、symbol、object、undefined、function等7种数据类型，但不能判断null、array等</p><blockquote><pre><code>typeof Symbol(); // symbol 有效typeof &apos;&apos;; // string 有效typeof 1; // number 有效typeof true; //boolean 有效typeof undefined; //undefined 有效typeof new Function(); // function 有效typeof null; //object 无效typeof [] ; //object 无效typeof new Date(); //object 无效typeof new RegExp(); //object 无效</code></pre></blockquote><p>2）instanceof<br>instanceof 是用来判断A是否为B的实例，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，但它不能检测null 和 undefined</p><blockquote><pre><code>[] instanceof Array; //true{} instanceof Object;//truenew Date() instanceof Date;//truenew RegExp() instanceof RegExp//truenull instanceof Null//报错undefined instanceof undefined//报错</code></pre></blockquote><p>3）严格运算符===<br>只能用于判断null和undefined，因为这两种类型的值都是唯一的。</p><p>4）constructor<br>constructor作用和instanceof非常相似。但constructor检测 Object与instanceof不一样，还可以处理基本数据类型的检测。<br>不过函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的constructor给覆盖了，这样检测出来的结果就是不准确的。</p><p>5）Object.prototype.toString.call()</p><blockquote><pre><code>Object.prototype.toString.call() 是最准确最常用的方式。Object.prototype.toString.call(&apos;&apos;) ;   // [object String]Object.prototype.toString.call(1) ;    // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]</code></pre></blockquote><h1 id="3-浅拷贝与深拷贝"><a href="#3-浅拷贝与深拷贝" class="headerlink" title="3.浅拷贝与深拷贝"></a>3.浅拷贝与深拷贝</h1><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</p><p>浅拷贝的实现方式（详见浅拷贝与深拷贝）：</p><pre><code>Object.assign()：需注意的是目标对象只有一层的时候，是深拷贝Array.prototype.concat()Array.prototype.slice()</code></pre><p>深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。</p><p>深拷贝的实现方式：</p><p>热门的函数库lodash，也有提供_.cloneDeep用来做深拷贝<br>jquery 提供一个$.extend可以用来做深拷贝<br>JSON.parse(JSON.stringify())<br>手写递归方法<br>递归实现深拷贝的原理：要拷贝一个数据，我们肯定要去遍历它的属性，如果这个对象的属性仍是对象，继续使用这个方法，如此往复。</p><blockquote><pre><code>//定义检测数据类型的功能函数function checkedType(target) {  return Object.prototype.toString.call(target).slice(8, -1)}//实现深度克隆---对象/数组function clone(target) {  //判断拷贝的数据类型  //初始化变量result 成为最终克隆的数据  let result,    targetType = checkedType(target)  if (targetType === &apos;Object&apos;) {    result = {}  } else if (targetType === &apos;Array&apos;) {    result = []  } else {    return target  }  //遍历目标数据  for (let i in target) {    //获取遍历数据结构的每一项值。    let value = target[i]    //判断目标结构里的每一值是否存在对象/数组    if (checkedType(value) === &apos;Object&apos; || checkedType(value) === &apos;Array&apos;) {      //对象/数组里嵌套了对象/数组      //继续遍历获取到value值      result[i] = clone(value)    } else {      //获取到value值是基本的数据类型或者是函数。      result[i] = value    }  }  return result}</code></pre></blockquote><h2 id="二、作用域和闭包"><a href="#二、作用域和闭包" class="headerlink" title="二、作用域和闭包"></a>二、作用域和闭包</h2><h1 id="1-执行上下文和执行栈"><a href="#1-执行上下文和执行栈" class="headerlink" title="1.执行上下文和执行栈"></a>1.执行上下文和执行栈</h1><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。<br>执行上下文的生命周期包括三个阶段：创建阶段执行阶段回收阶段，我们重点介绍创建阶段。</p><p>创建阶段（当函数被调用，但未执行任何其内部代码之前）会做以下三件事：</p><p>创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。<br>创建作用域链：下文会介绍<br>确定this指向：下文会介绍</p><blockquote><pre><code>function test(arg){// 1. 形参 arg 是 &quot;hi&quot;// 2. 因为函数声明比变量声明优先级高，所以此时 arg 是 functionconsole.log(arg);  var arg = &apos;hello&apos;; // 3.var arg 变量声明被忽略， arg = &apos;hello&apos;被执行function arg(){console.log(&apos;hello world&apos;) }console.log(arg);  }test(&apos;hi&apos;);/* 输出：function arg() {console.log(&apos;hello world&apos;);}hello */</code></pre></blockquote><p>这是因为当函数执行的时候,首先会形成一个新的私有的作用域，然后依次按照如下的步骤执行：</p><p>如果有形参，先给形参赋值<br>进行私有作用域中的预解释，函数声明优先级比变量声明高，最后后者会被前者所覆盖，但是可以重新赋值<br>私有作用域中的代码从上到下执行<br>函数多了，就有多个函数执行上下文，每次调用函数创建一个新的执行上下文，那如何管理创建的那么多执行上下文呢？</p><p>JavaScript 引擎创建了执行栈来管理执行上下文。可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。</p><p>从上面的流程图，我们需要记住几个关键点：</p><p>JavaScript执行在单线程上，所有的代码都是排队执行。<br>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。<br>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行完成后，当前函数的执行上下文出栈，并等待垃圾回收。<br>浏览器的JS执行引擎总是访问栈顶的执行上下文。<br>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</p><h1 id="2-作用域与作用域链"><a href="#2-作用域与作用域链" class="headerlink" title="2.作用域与作用域链"></a>2.作用域与作用域链</h1><p>ES6 到来JavaScript 有全局作用域、函数作用域和块级作用域（ES6新增）。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>在介绍作用域链之前，先要了解下自由变量，如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量。</p><blockquote><pre><code>var a = 100function fn() {var b = 200console.log(a) // 这里的a在这里就是一个自由变量console.log(b)}fn()</code></pre></blockquote><p>自由变量的值如何得到 —— 向父级作用域(创建该函数的那个父级作用域)寻找。如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p><blockquote><pre><code>function F1() {var a = 100return function () {    console.log(a)}}function F2(f1) {var a = 200console.log(f1())}var f1 = F1()F2(f1) // 100</code></pre></blockquote><p>上述代码中，自由变量a的值，从函数F1中查找而不是F2,这是因为当自由变量从作用域链中去寻找，依据的是函数定义时的作用域链，而不是函数执行时。</p><h1 id="3-闭包是什么"><a href="#3-闭包是什么" class="headerlink" title="3.闭包是什么"></a>3.闭包是什么</h1><p>闭包这个概念也是JavaScript中比较抽象的概念，我个人理解，闭包是就是函数中的函数(其他语言不能这样),里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。</p><p>闭包的作用：</p><p>使用闭包可以访问函数中的变量。<br>可以使变量长期保存在内存中，生命周期比较长。<br>闭包不能滥用，否则会导致内存泄露，影响网页的性能。闭包使用完了后，要立即释放资源，将引用变量指向null。</p><p>闭包主要有两个应用场景：</p><p>函数作为参数传递（见作用域部分例子）<br>函数作为返回值（如下例）</p><blockquote><pre><code>function outer() {var num = 0 //内部变量return function add() {//通过return返回add函数，就可以在outer函数外访问了。num++ //内部函数有引用，作为add函数的一部分了console.log(num)}}var func1 = outer() //func1() //实际上是调用add函数， 输出1func1() //输出2var func2 = outer()func2() // 输出1func2() // 输出2</code></pre></blockquote><h1 id="4-this全面解析"><a href="#4-this全面解析" class="headerlink" title="4.this全面解析"></a>4.this全面解析</h1><p>先搞明白一个很重要的概念 —— this的值是在执行的时候才能确认，定义的时候不能确认！ 为什么呢 —— 因为this是执行上下文环境的一部分，而执行上下文需要在代码执行之前确定，而不是定义的时候。看如下例子：</p><blockquote><pre><code>// 情况1function foo() {  console.log(this.a) //1}var a = 1foo()// 情况2function fn(){  console.log(this);}var obj={fn:fn};obj.fn(); //this-&gt;obj// 情况3function CreateJsPerson(name,age){//this是当前类的一个实例p1this.name=name; //=&gt;p1.name=namethis.age=age; //=&gt;p1.age=age}var p1=new CreateJsPerson(&quot;尹华芝&quot;,48);// 情况4function add(c, d){  return this.a + this.b + c + d;}var o = {a:1, b:3};add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34// 情况5&lt;button id=&quot;btn1&quot;&gt;箭头函数this&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;       let btn1 = document.getElementById(&apos;btn1&apos;);    let obj = {        name: &apos;kobe&apos;,        age: 39,        getName: function () {            btn1.onclick = () =&gt; {                console.log(this);//obj            };        }    };    obj.getName();&lt;/script&gt;</code></pre></blockquote><p>接下来我们逐一解释上面几种情况</p><p>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window<br>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象<br>在构造函数模式中，类中(函数体中)出现的this.xxx=xxx中的this是当前类的一个实例<br>call、apply和bind：this 是第一个参数<br>箭头函数this指向:箭头函数没有自己的this，看其外层的是否有函数，如果有，外层函数的this就是内部箭头函数的this，如果没有，则this是window。</p><h2 id="三、异步"><a href="#三、异步" class="headerlink" title="三、异步"></a>三、异步</h2><h1 id="1-同步-vs-异步"><a href="#1-同步-vs-异步" class="headerlink" title="1.同步 vs 异步"></a>1.同步 vs 异步</h1><p>同步，我的理解是一种线性执行的方式，执行的流程不能跨越。比如说话后在吃饭，吃完饭后在看手机，必须等待上一件事完了，才执行后面的事情。</p><p>异步，是一种并行处理的方式，不必等待一个程序执行完，可以执行其它的任务。比方说一个人边吃饭，边看手机，边说话，就是异步处理的方式。在程序中异步处理的结果通常使用回调函数来处理结果。</p><blockquote><pre><code>// 同步console.log(100)alert(200);console.log(300)  //100 200 300// 异步console.log(100) setTimeout(function(){   console.log(200) }) console.log(300) //100 300 200</code></pre></blockquote><h1 id="2-异步和单线程"><a href="#2-异步和单线程" class="headerlink" title="2.异步和单线程"></a>2.异步和单线程</h1><p>JS 需要异步的根本原因是 JS 是单线程运行的，即在同一时间只能做一件事，不能“一心二用”。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p><p>一个 Ajax 请求由于网络比较慢，请求需要 5 秒钟。如果是同步，这 5 秒钟页面就卡死在这里啥也干不了了。异步的话，就好很多了，5 秒等待就等待了，其他事情不耽误做，至于那 5 秒钟等待是网速太慢，不是因为 JS 的原因。</p><h1 id="3-前端异步的场景"><a href="#3-前端异步的场景" class="headerlink" title="3.前端异步的场景"></a>3.前端异步的场景</h1><p>前端使用异步的场景</p><p>定时任务：setTimeout，setInterval<br>网络请求：ajax请求，动态加载<br>事件绑定</p><h1 id="4-Event-Loop"><a href="#4-Event-Loop" class="headerlink" title="4.Event Loop"></a>4.Event Loop</h1><p>一个完整的 Event Loop 过程，可以概括为以下阶段：</p><p>一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</p><p>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</p><p>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。<br>执行渲染操作，更新界面<br>检查是否存在 Web worker 任务，如果有，则对其进行处理<br>上述过程循环往复，直到两个队列都清空<br>接下来我们看道例子来介绍上面流程：</p><blockquote><pre><code>Promise.resolve().then(()=&gt;{  console.log(&apos;Promise1&apos;)    setTimeout(()=&gt;{    console.log(&apos;setTimeout2&apos;)  },0)})setTimeout(()=&gt;{  console.log(&apos;setTimeout1&apos;)  Promise.resolve().then(()=&gt;{    console.log(&apos;Promise2&apos;)      })},0)最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2</code></pre></blockquote><p>一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2<br>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1<br>在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2<br>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</p><h2 id="四、原型链与继承"><a href="#四、原型链与继承" class="headerlink" title="四、原型链与继承"></a>四、原型链与继承</h2><h1 id="1-原型和原型链"><a href="#1-原型和原型链" class="headerlink" title="1.原型和原型链"></a>1.原型和原型链</h1><p>原型：在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p><p>原型链：JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p><blockquote><pre><code>var Person = function() {  this.age = 18  this.name = &apos;匿名&apos;}var Student = function() {}//创建继承关系,父类实例作为子类原型Student.prototype = new Person()var s1 = new Student()console.log(s1)</code></pre></blockquote><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<strong>proto</strong>（即它的构造函数的prototype）中寻找。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— Object.prototype.<strong>proto</strong> === null</p><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h1><p>介绍几种常见继承方式（如需了解更多，请点击JavaScript常见的六种继承方式）：</p><p>原型链+借用构造函数的组合继承</p><blockquote><pre><code>function Parent(value) {this.val = value}Parent.prototype.getValue = function() {console.log(this.val)}function Child(value) {Parent.call(this, value)}Child.prototype = new Parent()const child = new Child(1)child.getValue() // 1child instanceof Parent // true</code></pre></blockquote><p>以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。</p><p>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。</p><p>寄生组合继承：这种继承方式对上一种组合继承进行了优化</p><blockquote><pre><code>function Parent(value) {this.val = value}Parent.prototype.getValue = function() {console.log(this.val)}function Child(value) {Parent.call(this, value)}Child.prototype = Object.create(Parent.prototype, {constructor: {value: Child,enumerable: false,writable: true,configurable: true}})const child = new Child(1)child.getValue() // 1child instanceof Parent // true</code></pre></blockquote><p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p><p>ES6中class 的继承<br>ES6中引入了class关键字，class可以通过extends关键字实现继承，还可以通过static关键字定义类的静态方法,这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。需要注意的是，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。</p><blockquote><pre><code>class Parent {  constructor(value) {    this.val = value  }  getValue() {    console.log(this.val)  }}class Child extends Parent {  constructor(value) {    super(value)    this.val = value  }}let child = new Child(1)child.getValue() // 1child instanceof Parent // trueclass 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。</code></pre></blockquote><h2 id="五、DOM操作与BOM操作"><a href="#五、DOM操作与BOM操作" class="headerlink" title="五、DOM操作与BOM操作"></a>五、DOM操作与BOM操作</h2><h1 id="1-DOM操作"><a href="#1-DOM操作" class="headerlink" title="1.DOM操作"></a>1.DOM操作</h1><p>当网页被加载时，浏览器会创建页面的文档对象模型(DOM),我们可以认为 DOM 就是 JS 能识别的 HTML 结构，一个普通的 JS 对象或者数组。接下来我们介绍常见DOM操作：</p><blockquote><pre><code>新增节点和移动节点var div1 = document.getElementById(&apos;div1&apos;)// 添加新节点var p1 = document.createElement(&apos;p&apos;)p1.innerHTML = &apos;this is p1&apos;div1.appendChild(p1) // 添加新创建的元素// 移动已有节点。注意，这里是“移动”，并不是拷贝var p2 = document.getElementById(&apos;p2&apos;)div1.appendChild(p2)获取父元素var div1 = document.getElementById(&apos;div1&apos;)var parent = div1.parentElement获取子元素var div1 = document.getElementById(&apos;div1&apos;)var child = div1.childNodes删除节点var div1 = document.getElementById(&apos;div1&apos;)var child = div1.childNodesdiv1.removeChild(child[0])</code></pre></blockquote><h1 id="2-DOM事件模型和事件流"><a href="#2-DOM事件模型和事件流" class="headerlink" title="2.DOM事件模型和事件流"></a>2.DOM事件模型和事件流</h1><p>DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</p><p>（1）捕获阶段：事件从window对象自上而下向目标节点传播的阶段；</p><p>（2）目标阶段：真正的目标节点正在处理事件的阶段；</p><p>（3）冒泡阶段：事件从目标节点自下而上向window对象传播的阶段。</p><p>DOM事件捕获的具体流程</p><p>捕获是从上到下，事件先从window对象，然后再到document（对象），然后是html标签（通过document.documentElement获取html标签），然后是body标签（通过document.body获取body标签），然后按照普通的html结构一层一层往下传，最后到达目标元素。</p><p>接下来我们看个事件冒泡的例子：</p><blockquote><pre><code>// 事件冒泡&lt;div id=&quot;outer&quot;&gt;    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;......window.onclick = function() {    console.log(&apos;window&apos;);};document.onclick = function() {    console.log(&apos;document&apos;);};document.documentElement.onclick = function() {    console.log(&apos;html&apos;);};document.body.onclick = function() {    console.log(&apos;body&apos;);}outer.onclick = function(ev) {    console.log(&apos;outer&apos;);};inner.onclick = function(ev) {    console.log(&apos;inner&apos;);};</code></pre></blockquote><p>如何阻止冒泡？</p><p>通过event.stopPropagation() 方法阻止事件冒泡到父元素，阻止任何父事件处理程序被执行。<br>我们可以在上例中inner元素的click事件上，添加event.stopPropagation()这句话后，就阻止了父事件的执行，最后只打印了’inner’。</p><blockquote><pre><code> inner.onclick = function(ev) {    console.log(&apos;inner&apos;)    ev.stopPropagation()}</code></pre></blockquote><h1 id="3-事件代理-事件委托"><a href="#3-事件代理-事件委托" class="headerlink" title="3.事件代理(事件委托)"></a>3.事件代理(事件委托)</h1><p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</p><p>我们设定一种场景，如下代码，一个<div>中包含了若干个<a>，而且还能继续增加。那如何快捷方便地为所有<a>绑定事件呢？</p><blockquote><pre><code>&lt;div id=&quot;div1&quot;&gt;    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;&lt;/div&gt;&lt;button&gt;点击增加一个 a 标签&lt;/button&gt;</code></pre></blockquote><p>如果给每个<a>标签一一都绑定一个事件，那对于内存消耗是非常大的。借助事件代理，我们只需要给父容器div绑定方法即可，这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把父容器的click行为触发，然后把对应的方法执行，根据事件源，我们可以知道点击的是谁，从而完成不同的事。</p><blockquote><pre><code>var div1 = document.getElementById(&apos;div1&apos;)div1.addEventListener(&apos;click&apos;, function (e) {    // e.target 可以监听到触发点击事件的元素是哪一个    var target = e.target    if (e.nodeName === &apos;A&apos;) {        // 点击的是 &lt;a&gt; 元素        alert(target.innerHTML)    }})</code></pre></blockquote><p>最后，使用代理的优点如下：</p><p>使代码简洁<br>减少浏览器的内存占用</p><h1 id="4-BOM-操作"><a href="#4-BOM-操作" class="headerlink" title="4.BOM 操作"></a>4.BOM 操作</h1><p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p><blockquote><pre><code>window.screen对象：包含有关用户屏幕的信息window.location对象：用于获得当前页面的地址(URL)，并把浏览器重定向到新的页面window.history对象：浏览历史的前进后退等window.navigator对象：常常用来获取浏览器信息、是否移动端访问等等获取屏幕的宽度和高度console.log(screen.width)console.log(screen.height)</code></pre></blockquote><p>获取网址、协议、path、参数、hash 等</p><blockquote><pre><code>// 例如当前网址是 https://juejin.im/timeline/frontend?a=10&amp;b=10#someconsole.log(location.href)  // https://juejin.im/timeline/frontend?a=10&amp;b=10#someconsole.log(location.protocol) // https:console.log(location.pathname) // /timeline/frontendconsole.log(location.search) // ?a=10&amp;b=10console.log(location.hash) // #some</code></pre></blockquote><p>另外，还有调用浏览器的前进、后退功能等</p><blockquote><pre><code>history.back()history.forward()</code></pre></blockquote><p>获取浏览器特性（即俗称的UA）然后识别客户端，例如判断是不是 Chrome 浏览器</p><blockquote><pre><code>var ua = navigator.userAgentvar isChrome = ua.indexOf(&apos;Chrome&apos;)console.log(isChrome)</code></pre></blockquote><h1 id="5-Ajax与跨域"><a href="#5-Ajax与跨域" class="headerlink" title="5.Ajax与跨域"></a>5.Ajax与跨域</h1><p>Ajax 是一种异步请求数据的一种技术，对于改善用户的体验和程序的性能很有帮助。<br>简单地说，在不需要重新刷新页面的情况下，Ajax 通过异步请求加载后台数据，并在网页上呈现出来。常见运用场景有表单验证是否登入成功、百度搜索下拉框提示和快递单号查询等等。Ajax的目的是提高用户体验，较少网络数据的传输量。</p><p>如何手写 XMLHttpRequest 不借助任何库</p><blockquote><pre><code>var xhr = new XMLHttpRequest()xhr.onreadystatechange = function () {    // 这里的函数异步执行    if (xhr.readyState == 4) {        if (xhr.status == 200) {            alert(xhr.responseText)        }    }}xhr.open(&quot;GET&quot;, &quot;/api&quot;, false)xhr.send(null)</code></pre></blockquote><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。</p><p>那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。</p><p>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。</p><p>常见的几种跨域解决方案（具体如何实现详见九种跨域方式实现原理（完整版））：</p><p>JSONP：利用同源策略对<script>标签不受限制,不过只支持GET请求<br>CORS：实现 CORS 通信的关键是后端，服务端设置 Access-Control-Allow-Origin 就可以开启，备受推崇的跨域解决方案，比 JSONP 简单许多<br>Node中间件代理或nginx反向代理：主要是通过同源策略对服务器不加限制</p><h1 id="6-存储"><a href="#6-存储" class="headerlink" title="6.存储"></a>6.存储</h1><p>sessionStorage 、localStorage 和 cookie 之间的区别</p><p>共同点：都是保存在浏览器端，且都遵循同源策略。<br>不同点：在于生命周期与作用域的不同<br>作用域：localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下</p><p>生命周期：localStorage 是持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法是手动删除；而 sessionStorage 是临时性的本地存储，它是会话级别的存储，当会话结束（页面被关闭）时，存储内容也随之被释放。</p><p>三者区别</p><h2 id="六、模块化"><a href="#六、模块化" class="headerlink" title="六、模块化"></a>六、模块化</h2><p>几种常见模块化规范的简介（详情请点击前端模块化详解(完整版)）：</p><p>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案<br>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。<br>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM 打包，模块的加载逻辑偏重<br>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> js </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3经典问题</title>
      <link href="/2019/04/15/CSS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/15/CSS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp;BFC（Block FormattingContext）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。</p></blockquote><a id="more"></a> <h2 id="BFC应用"><a href="#BFC应用" class="headerlink" title="BFC应用"></a>BFC应用</h2><blockquote><ul><li>防止margin重叠</li><li>清除内部浮动</li><li>自适应两（多）栏布局</li><li>防止字体环绕</li></ul></blockquote><p>触发BFC条件</p><blockquote><ul><li>根元素</li><li>float的值不为none</li><li>overflow的值不为visible</li><li>display的值为inline-block、table-cell、table-caption</li><li>position的值为absolute、fixed</li></ul></blockquote><p>BFC的特性</p><blockquote><ul><li>内部的Box会在垂直方向上一个接一个的放置。</li><li>垂直方向上的距离由margin决定</li><li>bfc的区域不会与float的元素区域重叠。</li><li>计算bfc的高度时，浮动元素也参与计算</li><li>bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</li></ul></blockquote><h1 id="div水平居中"><a href="#div水平居中" class="headerlink" title="div水平居中"></a>div水平居中</h1><p>1.行内元素</p><pre><code>.parent {    text-align: center;}</code></pre><p>2.块级元素</p><pre><code>.son {    margin: 0 auto;}</code></pre><p>3.flex布局</p><pre><code>.parent {    display: flex;    justify-content: center;}</code></pre><p>4.绝对定位定宽</p><pre><code>.son {    position: absolute;    width: 宽度;    left: 50%;    margin-left: -0.5*宽度}</code></pre><p>5.绝对定位不定宽</p><pre><code>.son {    position: absolute;    left: 50%;    transform: translate(-50%, 0);}</code></pre><p>6.left/right: 0</p><pre><code>.son {    position: absolute;    width: 宽度;    left: 0;    right: 0;    margin: 0 auto;}</code></pre><hr><h2 id="div垂直居中"><a href="#div垂直居中" class="headerlink" title="div垂直居中"></a>div垂直居中</h2><p>1.行内元素</p><pre><code>.parent {        height: 高度;    }.son {    line-height: 高度;}</code></pre><p>2.table</p><pre><code>.parent {  display: table;}.son {  display: table-cell;  vertical-align: middle;}</code></pre><p>3.flex</p><pre><code>.parent {    display: flex;    align-items: center;}</code></pre><p>4.绝对定位定高</p><pre><code>.son {    position: absolute;    top: 50%;    height: 高度;    margin-top: -0.5高度;}</code></pre><p>5.绝对定位不定高</p><pre><code>.son {    position: absolute;    top: 50%;    transform: translate( 0, -50%);}</code></pre><p>6.top/bottom: 0</p><pre><code>.son {    position: absolute;    height: 高度;    top: 0;    bottom: 0;    margin: auto 0;}</code></pre><hr><h2 id="绝对定位和相对定位"><a href="#绝对定位和相对定位" class="headerlink" title="绝对定位和相对定位"></a>绝对定位和相对定位</h2><blockquote><ol><li>absolute 绝对定位 相对于最近的已定位的祖先元素, 有已定位(指position不是static的元素)祖先元素, 以最近的祖先元素为参考标准。如果无已定位祖先元素, 以body元素为偏移参照基准, 完全脱离了标准文档流</li><li>fixed   固定定位的元素会相对于视窗来定位,这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原本在页面应有的空隙。</li></ol></blockquote><p>共同点：改变行内元素的呈现方式，都脱离了文档流；不同点：absolute的”根元素“是可以设置的，fixed的“根元素”固定为浏览器窗口</p><hr><h2 id="让元素消失"><a href="#让元素消失" class="headerlink" title="让元素消失"></a>让元素消失</h2><pre><code>visibility:hidden、display:none、z-index=-1、opacity：0</code></pre><ul><li>opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发</li><li>visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</li><li>display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</li><li>z-index=-1置于其他元素下面</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习之旅 </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的新特性and选择器</title>
      <link href="/2019/04/15/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/04/15/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CSS3的新特性and选择器</p></blockquote><a id="more"></a><h2 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h2><ul><li>word-wrap 文字换行</li><li>text-overflow 超过指定容器的边界时如何显示</li><li>text-decoration 文字渲染</li><li>text-shadow 文字阴影</li><li>gradient 渐变效果</li><li>transition 过渡效果 </li><li>transition-duration：过渡的持续时间</li><li>transform 拉伸，压缩，旋转，偏移等变换</li><li>animation 动画</li></ul><p>transition和animation的区别：<br>  Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p><h2 id="CSS3选择器以及优先级"><a href="#CSS3选择器以及优先级" class="headerlink" title="CSS3选择器以及优先级"></a>CSS3选择器以及优先级</h2><p>!important<br>内联样式style=””<br>ID选择器#id<br>类选择器/属性选择器/伪类选择器.class.active[href=””]<br>元素选择器/关系选择器/伪元素选择器html+div&gt;span::after<br>通配符选择器*</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习之旅 </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css盒模型</title>
      <link href="/2019/02/16/css%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/02/16/css%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p> &emsp;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距margin，边框border，填充padding，和实际内容content。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p></blockquote><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/jinxb/jinxb.github.io/images/post2.jpg" alt="盒模型"></p><p><code>box-sizing: content-box</code>（W3C盒模型，又名标准盒模型）：元素的宽高大小表现为内容的大小。 <code>box-sizing: border-box</code>（IE盒模型，又名怪异盒模型）：元素的宽高表现为内容 + 内边距 + 边框的大小。背景会延伸到边框的外沿。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习之旅 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生于忧患,死于安乐</title>
      <link href="/2019/02/15/%E7%94%9F%E4%BA%8E%E5%BF%A7%E6%82%A3%EF%BC%8C%E6%AD%BB%E4%BA%8E%E5%AE%89%E4%B9%90/"/>
      <url>/2019/02/15/%E7%94%9F%E4%BA%8E%E5%BF%A7%E6%82%A3%EF%BC%8C%E6%AD%BB%E4%BA%8E%E5%AE%89%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2019年2月15日周五。</p></blockquote><a id="more"></a> <h2 id="大学生活转瞬即逝"><a href="#大学生活转瞬即逝" class="headerlink" title="大学生活转瞬即逝"></a>大学生活转瞬即逝</h2><p><img src="https://cdn.jsdelivr.net/gh/jinxb/jinxb.github.io/images/post1.jpg" alt="愁"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js知识点小结（预编译）</title>
      <link href="/2019/02/15/Js%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93%EF%BC%88%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%89/"/>
      <url>/2019/02/15/Js%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93%EF%BC%88%E9%A2%84%E7%BC%96%E8%AF%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>语法分析：js引擎在解析js代码之前，会通篇扫描一下，找出低级的语法错误（写错大括号之类的）。<br>编译执行：js是一种解释性语言，编译一行执行一行，当语法分析没有问题，并且已经完成预编译之后，便开始解释执行代码。</p></blockquote><a id="more"></a><h2 id="Js知识点小结（预编译）"><a href="#Js知识点小结（预编译）" class="headerlink" title="Js知识点小结（预编译）"></a>Js知识点小结（预编译）</h2><p><strong>js运行三部曲</strong></p><ol><li>语法分析</li><li><strong>预编译</strong></li><li>解释执行</li></ol><h2 id="预编译前奏"><a href="#预编译前奏" class="headerlink" title="预编译前奏"></a><strong>预编译前奏</strong></h2><p>1.imply global 暗示全局变量。</p><p>如果任何变量未经声明就赋值使用，此变量就会为<strong>全局对象window所有</strong>，并且成为window对象的一个属性。</p><pre><code>1. window.a = 123;2. window.a === a // true;</code></pre><p>或者</p><pre><code>1. a = 123;2. window.a === a //true</code></pre><p>2.一切<strong>声明</strong>的全局变量，都是window的属性。 </p><pre><code>1. var a =123;2. console.log(window.a); //123</code></pre><ul><li>区别：<strong>经过声明的全局变量不能通过delete操作来删除，但是未经声明的全局变量可以被删除。</strong></li></ul><pre><code>1. a = 123;2. console.log(wondow.a === a) //true3. delete window.a;4. console.log(window.a); //undefiend5. var b = 123;6. delete window.b;7. console.log(window.b); //123</code></pre><h2 id="预编译的过程总结为以下四步："><a href="#预编译的过程总结为以下四步：" class="headerlink" title="预编译的过程总结为以下四步："></a><strong>预编译的过程总结为以下四步</strong>：</h2><blockquote><p>1.创建AO对象。</p><p>2.寻找形参和变量声明，将变量和形参作为AO对象的属性名添加到对象中，值为undefined。值得注意的是，函数声明不叫变量。</p><p>3.将实参值和形参值相统一。</p><p>4.在函数体里面寻找函数声明，将函数名作为属性名，值为这个函数的函数体。 函数在执行的前一刻会产生一个上下文，这个上下文就是Activeaction Object对象，简称AO对象。 AO = {}</p></blockquote><p>这个对象是空的，但是里面有一些我们看不到的却存在的隐式属性，比如this:window属性和arguments:[]属性<br>这个对象用来存放一些属性和方法，这些属性和方法就按照前面的四步来产生。</p><pre><code>1. function test (a,b){2.    consolel.log a3.    function a(){}4.    a = 222;5.    console.log a6.    function b(){};7.    console.log b8.    var b = 111;9.    var a;10.  }11.  test(1)</code></pre><p>这里用上面这个样例代码来简单的介绍一下预编译过程。<br>1.创建一个AO对象。<br>var AO = {} ；<br>2.寻找形参值和变量声明，并且将其赋值为undefined。</p><pre><code>AO = {    a : undefined,    b : undefined}</code></pre><p>3.将实参值和形参值相统一。这里属性名已存在，直接赋值。</p><pre><code>AO = {    a : 1，    b : undefined}</code></pre><p> 4.寻找函数声明，将函数体赋值给属性。</p><pre><code>AO = {    a : function (){},    b : function (){}}</code></pre><p>第一个console.log a –&gt; function () {}<br>第二个console.log a –&gt; 222 因为执行了a = 222这一行代码，所以重新赋值了。<br>第三个console.log b –&gt; function () {}<br>• var b = function () {}这种不叫做函数声明，这个函数是赋值给b变量的，b变量是声明。</p><pre><code>function fn(a){    a //function    d //function    var a = 123;    a //123    function a(){}    b //undefined    var b = function (){}    b //function    function d(){}}</code></pre><p>这里的var b = function () {}只是声明了b变量，在第四步寻找函数声明里面并不会把b赋值成function () {}，因为后面的函数并不是声明，当代码开始解释执行之后，执行到这一行之后才把b赋值成这个函数。</p><p>• 寻找变量声明的时候，不会管里面的代码到底会不会执行，执行是后面的事，这里只负责寻找所有变量。</p><pre><code>function test(b){    a //undefined    if(1&gt;5){        var a = 123;        function b(){}    }    a //undefined    b //undefined    var b = 234;    b //234}test(2);</code></pre><p>打印第一个a的时候并不会报错而是undefined，当a没有声明的时候才会报错，因此这里a是有声明的，只是没有赋值而已，它根本不看有没有if，if的条件是不是真对寻找变量声明都没有关系。<br>第二步寻找形参和变量声明时候的AO对象：</p><pre><code>AO = {    a: undefined //这里a虽然在if里面 但是也被声明了    b: undefined}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习之旅 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
